# 3 -- что такое git

**Git** — это система контроля версий, которая позволяет удобно организовать рабочий процесс для команды разработчиков. Достигается это тем, что с помощью Git можно: сохранять разные состояния проекта и легко перемещаться между ними; делать новые ответвления от текущего состояния проекта, дабы “в изоляции” разрабатывать новые фичи; “подтягивать” новые изменения из других веток и довольно просто решать возникшие конфликты. При всём этом обилии полезных возможностей сам Git остаётся довольно маленькой и быстрой в работе утилиткой. Большая скорость обусловлена тем, что Git ставится и работает локально на вашем ПК. 

Историю изменений проекта Git хранит в виде набора “замороженных” состояний, к каждому из которых вы cможете в последствии вернуться. На каждом этапе сохранения нового состояния проекта в Git, система запоминает, как выглядит каждый файл в этот момент и сохраняет ссылку на это состояние. В конечном итоге получается длинная история из изменений, каждое из которых накладывает какой-то новый кусок кода на ваш проект.

# ==============================

# 4 -- схема работы кдаленного/локального репозиториев

Насколько бы “крут” и хорош не был Git, до тех пор, пока он хранит историю вашего проекта локально, он всё ещё не решает никаких проблем командной разработки. 

**GitHub** — это онлайн сервис для хранения проектов. Также он включает в себя и перечень возможностей систем контроля версий. Хранятся проекты на GitHub в виде репозиториев (сокращённо “репа” или “реп”, если говорить в множественном числе). Каждый репозиторий имеет свой уникальный URL и хранит в себе все файлы, ветки и полную историю вашего проекта. Именно отсюда, как правило, и начинается разработка новых проектов. Первым делом всегда создаётся репозиторий, а все разработчики “стягивают” его себе и продолжают работать с ним локально, периодически внося изменения обратно в удалённый репозиторий.

Распределённые системы контроля версий, к которым относится Git, предоставляют одну очень важную возможность: полная “выкачка” абсолютно всей информации из репозитория к себе на ПК. В итоге каждый разработчик имеет копию всех данных проекта и в случае утери (отказа или “слёта” удалённого сервера) можно будет с лёгкостью в полном объёме восстановить всю базу данных проекта.

# ==============================

# 5 -- основные возможности

- **git init** — инициализация нового репозитория;
- **git add** — поэтапное добавление изменений;
- **git commit** — регистрация некоторого перечня изменений с описанием и назначением уникального ID этим изменениям;
- **git status** — отслеживание текущего состояния репозитория;
- **git config** — запись и чтение конфигурации Git;
- **git branch** — отображение текущей ветки, создание новых веток, удаление веток;
- **git checkout** — переключение на другие ветки;
- **git merge** — слияние веток, т.е. соединение изменений двух веток в одну.

# ==============================

# 6 -- git init

Данная команда “превращает” директорию на вашем ПК в пустой репозиторий Git. Это первый шаг на пути создания репозитория. После выполнения данной команды можно приступать к добавлению и регистрации (созданию коммитов) изменений.

# ==============================

# 7 -- git add

С помощью данной команды можно добавлять изменённые (добавленные) файлы в некоего рода промежуточный источник данных Git. Это необходимо для дальнейшей регистрации (создание коммитов на их базе) этих изменений. Существует несколько способов добавления файлов: добавление файлов каждого по отдельности, добавление директории файлов или добавление всех изменений сразу.

# ==============================

# 8 -- git commit

Данная команда позволяет записать/зарегистрировать изменения, внесённые в файлы  локального репозитория. При этом новый набор изменений (в дальнейшем коммит) получает свой уникальный идентификатор, по которому его можно найти.

Хорошей практикой считается добавление исчерпывающего описания в сообщении нового коммита. Данное описание должно приводить объяснения к внесённым изменениям. В дальнейшем хорошие сообщения коммитов очень сильно упрощают поиск по истории изменений проекта.

# ==============================

# 9 -- git status

Данная команда сообщает вам о текущем состоянии репозитория.

Вызов команды git status отобразит ветку, на которой вы находитесь в данный момент. Кроме этого, если у вас есть файлы на стадии добавления, т.е. ещё не записанные в коммит, информация об этом также будет отображена. Если же никаких изменений готовых к регистрации нет, данная команда выведет сообщение “nothing to commit, working tree clean”.

# ==============================

# 10 -- git config

Git позволяет задавать нам множество самых разных настроек, а делается это с помощью команды git config. Самыми важными пунктами конфигурации являются user.name и user.email. Данные значения представляют собой информацию об авторе коммитов на локальном устройстве.

У команды git config есть флаг --global, который позволяет нам задать значение конфигурации для всех репозиториев сразу. Без данного флага настройки будут влиять лишь на текущий репозиторий.

Существует большое количество настроек, которые можно задать с помощью команды git config. Подробнее о них можно почитать [здесь](https://git-scm.com/docs/git-config).

# ==============================

# 11 -- git checkout

Данная команда нужна для смены рабочей (текущей) ветки. Используйте git checkout для переключения на новую ветку.

Также с помощью данной команды можно создавать новые ветки. В таком случае после вызова git checkout -b new-branch-name новая ветка будет создана и сразу же станет текущей.

# ==============================

# 12 -- git merge

Данная команда производит слияние изменений из двух веток. Как результат вызова git merge создаётся новый коммит, в котором находятся изменения текущей и целевой веток.

Частая ситуация: последние изменения из ветки dev (или develop) сливаются с изменениями на вашей ветке (feature). Это делается для того, чтобы получить доступ к новым возможностям из ветки dev или для разрешения конфликтов.

# ==============================

# 13 -- работа с удаленным репозиторием

- **git remote** — создание связи между локальным и удалённым репозиториями;
- **git clone** — создание локальной копии существующего удалённого репозитория;
- **git fetch** — получение данных об изменениях в ветке;
- **git pull** — получение самой последней версии репозитория;
- **git push** — отправка локальных изменений в виде перечня коммитов на удалённый репозиторий. 

# ==============================

# 14 -- git remote

Данная команда нужна для соединения локального репозитория с удалённым. При этом удалённый репозиторий может иметь какое-то название, чтобы не пришлось запоминать или хранить его полный URL-адрес.

# ==============================

# 15 -- git clone

Данная команда нужна для создания локальной копии существующего удалённого репозитория. После вызова команды git clone, git создаст новую директорию с именем равным названию удалённого репозитория и всем его содержимым (файлы, ветки, история изменений).

# ==============================

# 16 -- git fetch

Данная команда нужна для получения самых свежих данных с удалённого репозитория. Это могут быть новые ветки, коммиты и т.д. Однако важно понимать, что данная команда просто получает эти данные, но ничего с ними не делает.

# ==============================

# 17 -- git pull

Данная команда по сути совмещает в себе вызовы git fetch и git merge. Т.е. сначала идёт получение нового состояния ветки в удалённом репозитории, а затем автоматическое добавление новых данных в локальную ветку. При этом если ваша ветка уже находится в актуальном состоянии, то при вызове git pull будет выведено сообщение “Already up to date.”.

# ==============================

# 18 -- git push

Записывает локальные коммиты в удалённый репозиторий. Может принимать два параметра: название (или URL-адрес) удалённого репозитория и название ветки, изменения с которой мы хотим записать. Также в некоторых ситуациях данная команда может быть вызвана и без параметров.

# ==============================

# 19 -- бонусные команды

Для начала, конечно, стоит разобраться с командами с предыдущих слайдов, ибо они составляют основу, без которой сложно себе представить работу с системой контроля версий Git. 
Однако сразу после их усвоения на должном уровне, крайне рекомендую ознакомиться со следующим набором полезных команд: 
- **git stash** — сохранение текущего состояния репозитория и очищение директории от всех изменений; 
- **git cherry-pick** — вставка отдельного (-ых) коммита (-ов) в свою ветку; 
- **git rebase** — перемещение нескольких коммитов к новому базовому коммиту.

