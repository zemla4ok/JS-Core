# 3/4 -- стек

Стек следует принципу LIFO (Last In First Out — последним вошел, первым вышел). Если вы сложили книги друг на друга, и захотели взять самую нижнюю книгу, то сначала возьмете верхнюю, затем следующую и т.д. Кнопка «Назад» в браузере позволяет перейти (вернуться) на предыдущую страницу. 

Стек имеет следующие методы:
1) push: добавить новый элемент
2) pop: удалить верхний элемент, вернуть его
3) peek: вернуть верхний элемент
4) length: вернуть количество элементов в стеке

# ==============================

# 5/6 -- очередь

Очередь напоминает стек. Разница состоит в том, что очередь следует принципу FIFO (First In First Out — первым вошел, первым вышел). Когда вы стоите в очереди, первый в ней всегда будет первым.

Очередь имеет следующие методы: 
1) enqueue: войти в очередь, добавить элемент в конец
2) dequeue: покинуть очередь, удалить первый элемент и вернуть его
3) front: получить первый элемент
4) isEmpty: проверить, пуста ли очередь
5) size: получить количество элементов в очереди

# ==============================

# 7-9 -- связный список

Связный список — это цепочечная структура данных, где каждый узел состоит из двух частей: данных узла и указателя на следующий узел.

Односвязный список имеет следующие методы:
1) size: вернуть количество узлов
2) head: вернуть первый элемент (head — голова)
3) add: добавить элемент в конец (tail — хвост)
4) remove: удалить несколько узлов
5) indexOf: вернуть индекс узла
6) elementAt: вернуть узел по индексу
7) addAt: вставить узел в определенное место (по индексу)
8) removeAt: удалить определенный узел (по индексу)

# ==============================

# 10/11 -- Хэш-таблица(hash table)

Хеш-таблица — это структура данных, которая строится по принципу ключ-значение. Из-за высокой скорости поиска значений по ключам, она используется в таких структурах, как Map, Dictionary и Object. Как показано на рисунке, хеш-таблица имеет hash function, преобразующую ключи в список номеров, которые используются как имена (значения) ключей. Время поиска значения по ключу может достигать O(1). Одинаковые ключи должны возвращать одинаковые значения — в этом суть функции хэширования.

Хеш-таблица имеет следующие методы:
1) add: добавить пару ключ/значение
2) remove: удалить пару
3) lookup: найти значение по ключу

# ==============================

# 12 -- Дерево(tree)

Древовидная структура — это многослойная (многоуровневая) структура. Это также нелинейная структура, в отличие от массива, стека и очереди. Данная структура очень эффективна в части добавления и поиска элементов. Вот некоторые концепции древовидной структуры:

1) root: корневой элемент, не имеет «родителя»
2) parent node: прямой узел верхнего слоя (уровня), может быть только одним
3) child node: прямой узел (узлы) нижнего уровня, может быть несколько
4) siblings: дочерние элементы одного родительского узла
5) leaf: узел без «детей»
6) Edge: ветка или ссылка (связь) между узлами
7) Path: путь (совокупность ссылок) от начального узла до целевого элемента
8) Height of Tree (высота дерева): количество ссылок самого длинного пути от определенного элемента до узла, не имеющего потомков
9) Depth of Node (глубина узла): количество ссылок от корневого узла до определенного элемента
10) Degree of Node: количество потомков


# ==============================

# 13 -- прямой обход

Проверяем, не является ли текущий узел пустым или null.
Показываем поле данных корня (или текущего узла).
Обходим левое поддерево рекурсивно, вызвав функцию прямого обхода.
Обходим правое поддерево рекурсивно, вызвав функцию прямого обхода.
F, B, A, D, C, E, G, I, H.

# ==============================

# 14 -- центрированный обход

Проверяем, не является ли текущий узел пустым или null.
Обходим левое поддерево рекурсивно, вызвав функцию центрированного обхода.
Показываем поле данных корня (или текущего узла).
Обходим правое поддерево рекурсивно, вызвав функцию центрированного обхода.
A, B, C, D, E, F, G, H, I.

# ==============================

# 15 -- обратный обход

Проверяем, не является ли текущий узел пустым или null.
Обходим левое поддерево рекурсивно, вызвав функцию обратного обхода.
Обходим правое поддерево рекурсивно, вызвав функцию обратного обхода.
Показываем поле данных корня (или текущего узла).
Обратный порядок: A, C, E, D, B, H, I, G, F.
