# 3 -- зачем функции?

Очень часто в процессе разработки приложений мы встречаемся с ситуациями, когда какое-то действие приходится выполнять многократно. 
Например, добавление нового комментария на страницу, отображение оповещения или даже осуществление простой проверки строки на присутствие определённых символов. 

Для того, чтобы раз за разом не копировать один и тот же код в JavaScript есть функции. 
По сути функции являются основными “строительными блоками” любого программного кода. 

Вы уже наверняка сталкивались с некоторыми браузерными или встроенными в JavaScript функциями. 

Вот некоторые из них:
- alert(?text) - вызов модального окна браузера с текстом text;
- prompt(?message, ?defaultValue) - вызов модального окна браузера с сообщением message и полем для ввода со значением по умолчанию defaultValue; 
- parseFloat(string) - приведение строкового значения string к числу с плавающей точкой; 
- setTimeout(callback, delayInMs) - вызов функции callback с задержкой в delayInMs миллисекунд.

# ==============================

# 4 -- Объявление функции

Каждая функция имеет следующий перечень составляющих: 
- Имя (обязательно, исключение - анонимные функции); 
- Список аргументов; 
- Тело; 
- Возвращаемое значение (не обязательно).
  
Имя функции является “почти обязательным” элементом. Функции без имени вполне могут существовать. И, более того, используются довольно часто. Такие функции называются анонимными, но мы вернёмся к ним позже. 

Правила наименования функций почти ничем не отличаются от правил наименования переменных, однако имеют одно значительное смысловое отличие. В большинстве своем функции - это действия, поэтому имена функций зачастую содержат глаголы. Например: showWarningAlert, fetchUsers, markAsRead, compareCars и т.п.

** Хорошей практикой будет использование максимально “говорящих” (читабельных) имён для функций. Под этим имеется ввиду то, что при хорошем наименовании функции, вам сразу же должно становиться понятно, что она делает. Например, понятно ли вам, что делает функция delete(id)? Ну, наверное, что-то удаляет… А если функция названа deleteUserById(id)? Стало ли вам понятнее? Я думаю, что да.


# ==============================

# 5 -- Аргументы функции

Каждая функция должна иметь список аргументов. 
При этом даже если функция не принимает никаких аргументов, она всё равно должна это обозначить, оставив список пустым.

Начиная со стандарта ES6, у аргументов функции появилась возможность иметь значения по умолчанию. В случае, если один из таких аргументов не будет передан или передаваемое значение будет равняться undefined, - вместо него будет использовано значение по умолчанию.


# ==============================

# 6/7 -- “Безграничный” JavaScript

Любая функция в JavaScript может быть вызвана с неограниченным количество аргументов, даже если фактически было описано лишь конечное их число. Несложно догадаться, что JavaScript не поддерживает механизм перегрузки функций(1).
Получить доступ к аргументам функции можно
тремя способами:
- С помощью прямого описания каждого из
аргументов;
- С помощью псевдомассива arguments
(устаревший вариант, полный список
аргументов);
- С помощью rest-оператора (новшество ES6,
полный или остаточный список аргументов).

(1) Перегрузка функций - это механизм языка, позволяющий описать несколько вариантов вызова функции с разным набором аргументов.


# ==============================

# 8 -- Возвращаемое значение

Помимо выполнения какого-то кода, функции могут ещё и возвращать результат. По умолчанию любая функция в JavaScript возвращает значение undefined.

Для возвращения результата нужно внутри тела функции использовать ключевое слово return и через пробел указать возвращаемое значение. 
Return может быть вызван в любом месте функции, однако после его вызова функция тут же завершит свою работу, а весь оставшийся код будет проигнорирован. 
Тем не менее, это вовсе не значит, что return может быть использован в теле функции лишь один раз.

Кроме этого return может быть вызван и без значения. Втаком случае функция также завершит свою работу, а возвращаемым значением вновь станет undefined.


# ==============================

# 9 -- Что может вернуть?

Возвращаемым значением функции может являться в буквальном смысле всё! Любой примитив, объект и даже другая функция.

Отдельно можно выделить случаи возникновения ошибок. Да, это не совсем то, что обычно понимается под возвращаемым значением, но, так или иначе, если во время выполнения функции JavaScript (или вы сами) сгенерирует ошибку, то функция тут же завершится, а результатом будет как раз та самая ошибка. Это значение можно отловить с помощью обёртки соответствующей части кода в конструкцию try .. catch.

# ==============================

# 10 -- Виды функций 

В JavaScript существует три основных типа функций:
•Объявляемая функция (function declaration);
•Функциональное выражение (function expression);
•Стрелочная функция (arrow function, ES6).

# ==============================

# 11 -- "Состояния" функций

Кроме этого есть ещё некоторые “состояния” функций:
•Callback-функция (callback function);
•Функция-конструктор (constructor function);
•Функция высшего порядка (higher-order function).

# ==============================

# 12 -- function declaration

Объявляемые функции - это функции, которые объявляются самым обычным способом с помощью ключевого слова function.

Такие функции имеют одну довольно значимую особенность - они “всплывают”. 
Это означает, что такие функции могут быть использованы (вызваны) раньше, чем фактически объявлены в коде.

# ==============================

# 13 -- function expression

Функциональные выражения – это способ объявления функций через переменную. 
Т.е. мы описываем функцию обычным способом, но вместо задания имени складываем её в переменную.

В таком случае «всплывать» функция уже, естественно, не будет. Обратиться к ней можно будет лишь после непосредственной инициализации.


# ==============================

# 14 -- arrow functions

Стрелочные функции появились в JavaScript в стандарте ES6 и сами по себе существенно отличаются от остальных типов. 
Во-первых, краткий и более удобный синтаксис. 
Во-вторых, отсутствие псевдомассива arguments. 
В-третьих, нет своего this (он берётся сверху), отчего стрелочные функции не могут быть использованы как функции-конструкторы. 
В-четвёртых, нет super (как и в случае с this, он берётся сверху). 
В-пятых, если тело стрелочной функции состоит всего из одного выражения, то фигурные скобки можно опустить, 
    а возвращаемым значением функции будет результат этого выражения. Примеры:

** Стрелочные функции крайне удобно использовать в качестве callback-функций или же в случае описания функциональных выражений. Всё это идёт по большей части от простоты синтаксиса.

# ==============================

# 15 -- callback функции

Callback-функция – это любая функция, передаваемая в качестве аргумента. В интернете можно найти и более «развёрнутое» описание, но, так или иначе, все они сводятся к одному и тому же.
Такие функции нужны для того, чтобы использовать их внутри других функций. До появления промисов они очень широко использовались для обработки http-запросов. Сейчас, естественно, эту нишу они потеряли, но несмотря на это используются они и по сей день довольно часто. В качестве хорошего примера использования можно привести перебирающие методы массива.


# ==============================

# 16 -- функции-конструкторы

Функции-конструкторы – специальные функции, предназначенные для создания (конструирования) новых объектов. 
Такие функции, как правило, не предназначены для прямого вызова, ибо толку с этого будет не много (хотя делать это всё ещё можно). 
Эти функции нужны для вызова со специальным оператором new.

** Подробнее о том, как работают функции-конструкторы при вызове через new мы поговорим на лекции про ООП.

# ==============================

# 17 -- функция высшего порядка

Функции высшего порядка – это функции, которые или принимают другие функции в виде аргументов (работа с callback-функциями), 
или возвращает функцию в качестве результата. 
И вновь в качестве хорошего примера подойдут перебирающие методы массивов или метод bind, как пример встроенного метода, возвращающего функцию в качестве результата.

Функции высшего порядка не могут существовать в языках, не поддерживающих механизм объектов (функций) первого класса. Функция первого класса – это функция, которая может выступать в роли аргумента функции, быть возвращаемым значением функции и выступать в роли значения для переменной или поля объекта. Пример функции высшего порядка (“полифилл” bind):

# ==============================

# 18 -- локальные переменные 

Говоря о функциях высшего порядка, никак нельзя обойти стороной тему замыканий в JavaScript. Но перед тем как перейти к самим замыканиям нужно разобраться с понятиями локальных и глобальных переменных.

Локальные переменные – это переменные, созданные в рамках некоторой ограниченной области видимости. Для переменных, созданных с помощью let или const такой областью является блок. Для переменных, созданных с помощью var – функция.

Локальные переменные существуют лишь в рамках своей области видимости. За её пределами обратиться к ним невозможно. (будет сгенерирована ошибка).

# ==============================

# 19 -- Глобальные переменные

Глобальные переменные – это любые переменные, созданные вне какой-либо ограничивающей области видимости. Также к глобальным переменным можно отнести поля глобального объекта (window для браузеров, global  для Node.js и т.п.).

# ==============================

# 20 -- lexical environment

Лексическое окружение – это специальный объект, хранящий в себе информацию обо всех локальных переменных и ссылку на внешнее окружение 
(внешний lexical environment). 
Данный объект скрыт и получить к нему прямой доступ нельзя. 
Тем не менее в нынешних реалиях можно чётко обозначить его две ключевые составляющие: Environment Record – объект, хранящий в себе все локальные переменные (и ещё некоторую другую информацию, как, например, значение this) и outer – ссылку на внешнее лексическое окружение.

По сути все локальные переменные – это переменные скрытого объекта внутри лексического окружения. То есть при попытке получения доступа к какой-то переменной, первым делом идёт обращение к этому объекту, чтобы достать значение с таким именем оттуда, а затем (в случае неудачи), идёт обращение по скрытой ссылке outer к объекту переменных внешнего окружения. Цикл повторяется до тех пор, пока: а) переменная не будет найдена, б) не закончится цепочка внешних окружений.

** Каждое приложение также имеет глобальное лексическое окружение, выше которого ничего нет (outer ссылается на null).

# ==============================

# 21 -- замыкания 

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.

Замыкание - это комбинация функции и лексического окружения, в котором эта функция была определена.

В JavaScript почти(1) все функции являются замыканиями.

(1) Исключением является способ создания функций через new Function(). Любая функция созданная таким способом всегда ссылается на глобальную область видимости.
