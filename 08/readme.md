# 3 -- Как работает JS?

JavaScript – это синхронный и однопоточный язык программирования.

Что значит синхронный? Предположим, что у нас есть две строки кода. Первая идёт за второй. Синхронность означает то, что 2 строка не может начать выполняться до тех пор, пока 1 строка не завершит свою работу.

Что значит однопоточный? Тут всё ещё проще. Однопоточность в JavaScript выражается тем, что лишь один блок кода может запускаться за раз.

На этом моменте должен возникнуть вопрос: а как в таком случае в JavaScript достигается асинхронность? Ведь мы же знаем, что в наших программах довольно часто встречаются какие-то асинхронные операции (setTimeout, http-запросы и т.д.). Давайте разбираться.

# ==============================

# 4 -- Параллелизм

# ==============================

# 5 -- Синхронный код 

# ==============================

# 6 -- Асинхронность в JavaScript

Пока код выполняется исключительно синхронно, в целом всё довольно просто. Однако в случаях, когда “в бой вступает” асинхронность, ситуация резко меняется.

Асинхронность – это определённая модель поведения. Вновь представим, что у нас есть две строчки кода. Одна идёт за другой. Однако в этот раз операции в первой строке нужно некоторое время (10 секунд) на выполнение. В итоге она начинает выполняться “где-то на фоне", в то время как вторая строка кода запускается, не дожидаясь завершения первой.

** Если выполнять абсолютно весь код синхронно, то приложение очень часто будет “подвисать”. Например, обработать запрос с сервера. Или же обработать данные файла. Да и вообще много чего ещё может тратить заметное время на выполнение. Если в такие моменты наше приложение будет полностью “зависать”, то пользоваться таким приложением будет крайне неудобно.

# ==============================

# 7 -- Как это тогда работает?

Как мы выяснили ранее, JavaScript – это синхронный и однопоточный язык программирования. Как же тогда в нём могут работать асинхронные операции?

Всё дело в механизме под названием Event Loop (по-русски цикл событий, но лучше запомнить как event loop). Именно Event Loop делает возможным выполнение всех асинхронных операций в JavaScript. Достигается это тем, что задачи выстраиваются в специальные очереди и подаются на выполнение (по одной или сразу все в зависимости от типа задачи) лишь тогда, когда стек вызова “ничем не занят”.

JavaScript не в состоянии самостоятельно обработать асинхронный код. Этим всегда занимается “кто-то другой” (окружение, в котором запускается код).

** В случае, когда мы запускаем наш код в браузере, обработкой асинхронных операций занимается WebAPI.

# ==============================

# 8 -- EventLoop

На самом деле Event Loop может включать в себя куда больше разных инструментов. Всё зависит от того, в каком окружении мы запускаем наш код. Сегодня же мы будем рассматривать  Event Loop исключительно в рамках браузера (и то не полностью, рендеринг затрагивать мы не будем).

Heap – куча, место хранения объектов, большая неструктурированная область памяти.

Stack – наш стек вызова.

Web APIs – набор готовых инструментов, предоставляемых браузерным окружением.

Callback queue (или task queue) – очередь задач. Здесь хранятся задачи готовые к выполнению.

# ==============================

# 9/10 -- Callback/Callback hell

В примерах выше можно было увидеть один из подходов для работы с асинхронным кодом в JavaScript. Это подход с использованием callback-функций. Работает это очень просто: мы вызываем setTimeout, делаем http-запрос или даже навешиваем обработчик на событие через addEventListener и затем передаём callback-функцию, которая будет вызвана, когда таймер завершится/запрос вернёт ответ/событие произойдёт.

Данный подход долго являлся по сути единственным из возможных для работы с асинхронными операциями. Но в нём были проблемы. Пока операций было немного или они находились далеко друг от друга, всё выглядело и работало хорошо. Однако, когда появлялись цепочки вызовов, как например: запрос за получение данных с сервера, в callback-функции обработчике новый запрос в другой источник, где в обработчике есть ещё один запрос в третий источник и т.д. Код становился очень громоздким, менее читаемым и быстрыми темпами в буквальном смысле расширялся. Такая вложенность существенно “уводила” код в правую часть экрана. Это именно то, что очень часто называют “callback hell” (ад обратных вызовов).

Из этой ситуации нужен был выход. И он нашёлся.

# ==============================

# 11 -- Promise 

Промисы стали шикарным решением всех проблем. С их появлением ушла удручающая ситуация с разрастающимся в бок кодом и на смену пришла очень красивая цепочка вызовов.

Промис – это объект, представляющий асинхронную задачу и результат её выполнения. Он может находиться в одном из трёх состояний: ожидание (pending), завершён успешно (fulfilled), завершён с ошибкой (rejected).

# ==============================

# 12 -- состояния Promise 

# ==============================

# 13 -- Promise методы

Экземпляр промиса содержит три метода:
- then(callbackOnResolve, callbackOnReject);
- .catch(callbackOnReject);
- .finally(callback).

С помощью этих методов и выстраивается цепочка вызовов. В случае, когда нам нужно обработать успешный результат предыдущей операции – используем then. Когда нужно обработать неудачный сценарий – используем catch. Когда нужно независимо от ситуации выполнить какое-то стороннее действие – используем finally.

** Метод then также может использоваться и для обработки неудачных сценариев. Однако делать этого не рекомендуется, т.к. catch лучше подходит для этой задачи.

# ==============================

# 19 -- Bluebird 

# ==============================

# 20 -- Задачи

В Event Loop есть две очереди задач: мАкрозадачи (tasks/macrotasks) и мИкрозадачи (jobs/microtasks).
Макрозадачи выполняются по очереди, по одной за раз (т.е. за одну итерацию Event Loop). В качестве примеров макрозадач можно привести callback-функции, переданные в качестве параметров для setTimeout, обработки браузерных событий, XMLHttpRequest или fetch. Каждая из этих задач является асинхронной и по готовности будет добавлена в очередь макрозадач.
Одна задача — это всегда какая-то функция, подлежащая выполнению где-то в будущем. Каждая новая задача может быть взята на выполнение только тогда, когда стек вызова пуст. Задача может считаться завершённой, когда стек вызова снова становится пустым.

Микрозадачи выполняются также по очереди, но в отличие от макрозадач все за раз (то есть за одну итерацию Event Loop). Причём даже если некоторые из микрозадач были добавлены в процессе выполнения предыдущих, они всё равно будут выполнены в текущей итерации(1). Примеры микрозадач: callback-функции для обработки Promise и Mutation Observer.
Отдельного внимания заслуживает порядок выполнения задач. Event Loop “заглядывает” в очередь микрозадач после каждого выполнения макрозадачи. Т.е. по сути для перехода к следующей макрозадаче должны выполнится все существующие микрозадачи.
(1) Из этого следует то, что микрозадачи вполне могут послужить причиной полного зацикливания приложения.

# ==============================

# 22/23 -- HTTP 

Аббревиатура HTTP расшифровывается как HyperText Transfer Protocol (протокол передачи гипертекста). Это название было закреплено за протоколом HTTP уже очень давно и с тех пор многое изменилось. Очевидно, что на сегодняшний день данный протокол имеет куда больший спектр возможностей, чем просто пересылка документов разметки.
По-простому HTTP — это протокол, позволяющий получать различные данные в Интернете. Он является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем (обычно браузером). Полученный документ также может состоять из различных частей: например, из отдельно полученного текста, описания структуры документа, изображений, видео-файлов, скриптов и многого другого.
Клиент и сервер взаимодействуют, обмениваясь одиночными сообщениями (а не потоком данных). Сообщения, отправленные клиентом (обычно браузером), называются запросами, а сообщения, отправленные сервером, называются ответами.

# ==============================

# 24 -- HTTP-методы 

# ==============================

# 25 -- Свойства HTTP-методов 

HTTP определяет множество методов запроса, которые указывают, какое действие нужно выполнить для данного ресурса. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кешируемыми.
- HTTP-метод считается безопасным только в том случае, если он никак не меняет состояние приложения на сервере. Другими словами, метод безопасен, если он осуществляет операцию, направленную только на чтение данных.
- HTTP-метод считается идемпотентным, если несколько его вызовов, произведённых в ряд, приведут к одному и тому же результату и к тому же каждый раз сервер будет оставаться в одном и том же состоянии.
- Ответ HTTP-запроса считается кешируемым, если он может быть закеширован, с целью сохранения результата и переиспользования его в будущем, вместо осуществления нового запроса. Это делается с целью снижения количества запросов к серверу.

# ==============================

# 26 -- Заголовки 

Заголовки HTTP — это строки в HTTP-сообщении, содержащиеся в запросах в уже знакомом нам представлении “ключ: значение”. Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.
Все заголовки делятся на четыре основные группы:
1.General Headers (основные заголовки) — должны включаться в любое сообщение клиента и сервера.
2.Request Headers (заголовки запроса) — используются только в запросах клиента.
3.Response Headers (заголовки ответа) — только для ответов от сервера.
4.Entity Headers (заголовки сущности) — сопровождают каждую сущность сообщения.

# ==============================

# 27 -- Запросы в JS

Способов отправки HTTP-запросов в JavaScript несколько. Можно воспользоваться HTML-формами (хоть это и не совсем JavaScript, но всё же). Или же воспользоваться встроенными в браузер инструментами, такими как: объект XMLHttpRequest или метод fetch (наиболее предпочтительный вариант).

Также есть несколько популярных сторонних библиотек, предоставляющих функциональность для осуществления HTTP-запросов. Самые популярные из них Axios и jQuery.

XMLHttpRequest, fetch, Axios и jQuery.ajax для осуществления HTTP-запросов используют подход AJAX (Asynchronous JavaScript and XML — “асинхронный JavaScript и XML”). Данный подход подразумевает выполнение HTTP-запросов без перезагрузки страницы с изменениями, производимыми прямо “на лету”. Все самые популярные JavaScript-фреймворки, (React, Angular, Vue) продвигающие идею одностраничных приложений (SPA — Single Page Application), полностью строятся на подходе AJAX.














