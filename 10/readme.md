# 3 -- JavaScript и “его” окружения

Изначально JavaScript создавался для работы с браузерами. Его главной задачей было добавление веб-страничкам интерактивности, т.е. 
Возможности для взаимодействия с пользователями.
На сегодняшний день JavaScript существенно “подрос” и стал полноценным языком программирования для решения по-настоящему широкого круга задач. 
Несмотря на то, что до сегодняшнего дня за ним сохраняется роль флагмана front-end разработки, он свободно может выполняться как на сервере, 
так и на любом другом устройстве, которое сможет запустить “движок” JavaScript.
Каждое окружение предоставляет свой набор дополнительных возможностей (функций и объектов) характерных только для него. 
Так, например, в случае с браузером это объекты navigator, screen, document или функции setTimeout, setInterval, prompt, confirm и т.д. 
Когда JavaScript запускается в браузере, он автоматически получает доступ ко всем этим возможностям. 
С другими окружениями ситуация обстоит таким же образом.
** В рамках текущей лекции мы подробно остановимся на браузерном окружении.

# ================================================================

# 4 -- Браузерное окружение

Получить доступ к браузерному API можно с помощью глобального объекта window. При этом данный объект включает в себя и объектную модель документа (DOM), и объектную модель браузера (BOM), а также объекты и функции JavaScript. По итогу выходит, что window — это и объект браузерного окружения, и глобальный объект для JavaScript.
DOM — это объектная модель документа, создаваемая в процессе загрузки веб-страницы на основе специальных объектов.
BOM — совокупность инструментов, поставляемых браузером.

# ================================================================

# 5 -- DOM

DOM представляет собой всё содержимое html-страницы в виде иерархии специальных объектов, которые можно менять. Особое место в этой модели занимает объект document. Он является ключевым объектом для работы с DOM.
1.С помощью document мы можем обратиться к любому элементу страницы.
2.Document включает в себя исчерпывающий набор функций для создания, удаления и изменения контента на странице.
3.Кроме этого с помощью document можно получить некоторую информацию о самом документе (тип, адрес, домен и т.п.).

# ================================================================

# 6 -- BOM

BOM представляет собой набор функций и объектов, предоставленных браузером.
Например, из упомянутого ранее объекта navigator можно достать много информации о приложении, запустившем скрипт (например, браузере, операционной системе и много о чем ещё). Объект location содержит информацию о текущем URL-адресе и позволяет производить некоторые манипуляции с ним.
BOM является частью общей спецификации HTML. Из этого следует, что спецификация HTML на самом деле является не только описанием того, как работает сам язык разметки HTML, но и ряда инструментов для работы с ним.


# ================================================================

# 7/8 --DOM-дерево

Основой любого HTML-документа являются теги.
При этом, согласно объектной модели документа, каждый тег является объектом. Также каждый тег является элементом в DOM-дереве (об этом позже). Вложенные теги являются «детьми» родительских элементов. У последних, в свою очередь, могут быть свои вложенные элементы и так далее. Таким образом выстраивается иерархия (дерево) элементов HTML-страницы.
Текстовые фрагменты и комментарии также являются узлами DOM-дерева. При этом содержимое тега script с точки зрения документа также является текстом 

УЗЛЫ
В DOM-дереве есть два основных типа узлов: обычные узлы и узлы-элементы (или просто элементы). Абсолютно всё, что вы видите на странице HTML-документа, состоит из узлов (частные случаи которых представлены элементами).
Ещё раз, узлом является всё: фрагмент текста, поле для ввода (input), комментарий, переход на новую строку, любой блок (например, div) и так далее-далее. Элементы также являются узлами, но с расширенным кругом возможностей.
В WebAPI узлы представлены интерфейсом Node. От этого интерфейса наследуются все остальные узлы и элементы в том числе (опять же узлы-комментарии, текстовые узлы, фрагменты документа (DocumentFragment) и т.д.). Каждый объект узла имеет свойства для получения коллекции (перебираемого псевдомассива) дочерних узлов (childNodes), типа узла (nodeType) и многие другие. Кроме того, объекты узлов содержат целый ряд методов среди которых есть методы для вставки (appendChild), удаления (removeChild), клонирования (cloneNode) узлов и т. д.

ЭЛЕМЕНТЫ
Элементами являются все наши теги. В целом в рамках разработки приложений мы в 99.99% случаев хотим работать только с элементами, а не со всеми узлами.
Как и узлы, элементы имеют своё представление в WebAPI, а именно: интерфейс Element. Данный интерфейс предоставляет расширенный набор свойств, включающий в себя свойства, направленные на работу исключительно с элементами. Например, свойство children возвращает коллекцию (перебираемый псевдомассив), содержащую все дочерние элементы. Свойство nextElementSibling содержит ссылку на следующий элемент в дереве или null, если такой отсутствует. Использовать его “старшего брата” nextSibling в большинстве случаев неудобно, т.к. в качестве значения можно получить абсолютно любой узел (даже текстовый узел или комментарий).
Элементы составляют костяк интерфейса и возможностей работы с ним. Мы можем навешивать на них обработчики событий, менять их содержимое и внешний вид. Для назначения обработчиков есть встроенный метод addEventListener (подробнее об этом мы поговорим на соответствующей лекции). Для задания инлайновых стилей есть специальное свойство style (о нём мы также поговорим на одной из следующих лекций).

ОСНОЫНЫЕ ЭЛЕМЕНТЫ DOM
С помощью DOM мы вольны делать всё, что угодно, с внешним видом и содержимым наших элементов. Однако прежде чем производить над ними какие-то операции, их необходимо получить.
Объект document является корневым и входным объектом DOM-дерева. Другие узлы дерева не могут быть получены без доступа к document. Кроме того document имеет несколько свойств, которые содержат в себе ссылки на ключевые элементы DOM-дерева. Это свойства documentElement, head и body. В них соответственно находятся ссылки на html-элемент (<html></html>), head-элемент (<head></head>) и body-элемент (<body></body>) нашей страницы. Сделано это, очевидно, для упрощения доступа к элементам, которые являются обязательными в каждом html-документе. Ко всем остальным элементам получить доступ можно несколько иначе. Однако кое-что всегда остаётся неизменным — любой элемент со страницы может быть получен через document.

# ================================================================

# 9 -- Навигация по DOM

Для навигации по DOM существует множество встроенных инструментов:
1.Свойства узлов для получения родительского узла/элемента. ParentNode и parentElement(1) соответственно.
2.Свойства элементов для получения соседних узлов/элементов. Например: previousSibling, nextElementSibling и т.д.
3.Свойства элементов для получения дочерних узлов/элементов. Например: childNodes, children, firstChild, lastElementChild и т.д.
(1) ParentNode для элемента <html> вернёт document, а parentElement — null.

# ================================================================

# 10 -- Поиск элементов в DOM

Описанные выше способы поиска элементов являются довольно специфичными и в большинстве случаев нам не подойдут. Найти с их помощью элемент на большом уровне вложенности или же собрать целый список похожих элементов станет очень трудоёмкой задачей.
Для поиска элементов в DOM есть целый ряд встроенных методов. Часть из них существует непосредственно в объекте document. Остальные же присутствуют вообще у всех элементов, т.е. каждый элемент может выступить в качестве “точки отсчёта”, от которой будет идти поиск по дереву вниз.

# ================================================================

# 11 -- Document.getElementById(id)

Результатом вызова будет элемент, имеющий переданный в качестве параметра идентификатор или null, если такого не найдётся.
В рамках всего документа ни один идентификатор не должен повторяться. В ином случае результат вызова метода getElementById будет непредсказуем, т.к. у каждого браузера описано своё поведение на такой случай.

# ================================================================

# 12 -- getElementsBy(Class/Tag)Name

Результатом вызова метода getElementsByClassName будет коллекция (перебираемый псевдомассив) из дочерних элементов любой вложенности, которые имеют переданный в качестве параметра класс. Если таковых не найдётся, то в качестве результата мы получим пустую коллекцию.
Результатом вызова метода getElementsByTagName будет коллекция (перебираемый псевдомассив) из дочерних элементов любой вложенности, которые имеют переданный в качестве параметра тег. Если таковых не найдётся, то в качестве результата мы получим пустую коллекцию.

# ================================================================

# 13 -- querySelector(All)

Результатом вызова метода querySelector будет первый элемент среди дочерних на любой вложенности, который соответствует переданному css-селектору, или же null, если такого не найдётся.
Результатом вызова метода querySelectorAll будет коллекция (перебираемый псевдомассив) из дочерних элементов любой вложенности, которые соответствуют переданному css-селектору. Если таковых не найдётся, то в качестве результата мы получим пустую коллекцию.

# ================================================================

# 14 -- “Живые” и “неживые” коллекции

Методы семейства getElementsBy* возвращают “живые" коллекции, в то время как метод querySelectorAll возвращает “неживые” (статические).
Отличие “живой” коллекции от “неживой” заключается в том, что первая как бы синхронизируется (сразу же реагирует на изменения) с текущим состоянием документа, а вторая — нет. Например, если мы сначала получим все элементы с классом cell при помощи метода getElementsByClassName, а затем удалим из документа один из них, то в нашей коллекции он также исчезнет. Если же мы проделаем всё тоже самое, но вместо getElementsByClassName используем querySelectorAll, то даже после удаления элемента из DOM наша коллекция не изменится. Можно сказать, что querySelectorAll “делает снимок” состояния документа на момент осуществления запроса.

# ================================================================

# 15 -- Ещё полезные методы

1.Определение соответствия элемента css-селектору:
Element.matches(‘a[target=“_blank”]');
Результатом вызова будет true, если элемент соответствует переданному css-селектору, или false в ином случае.
2.Поиск ближайшего предка по css-селектору:
Element.closest(‘.wrapper’);
Результатом вызова будет первый элемент, который соответствует переданному css-селектору из списка [текущий элемент, родитель текущего элемента, родитель родителя текущего элемента, …]. Если такого элемента не нашлось, то результатом будет null.
3.Определение отношений между элементами:
elem1.contains(elem2);
Результатом вызова будет true, если elem2 находится внутри elem1 или если elem1 === elem2. В остальных случаях результатом будет false.

# ================================================================

# 16 -- Браузерные события

Событие — это сигнал от браузера о том, что что-то произошло. Все элементы DOM (а также document и window) подают такие сигналы. Несмотря на то, что сегодня мы будем рассматривать события только в рамках браузера, естественно, события — это механизм свойственный не только для них. Некоторые из самых распространённых событий:
•click/dblclick (mouse) — клик/двойной клик по элементу левой кнопкой мыши (на сенсорных устройствах касание/двойное касание);
•contextmenu (mouse) — клик по элементу правой кнопкой мыши;
•mouseover/mouseout (mouse) — наведение/убирание курсора мыши с элемента;
•keydown/keyup (keyboard) — нажатие/отпускание клавиши на клавиатуре;
•focus/blur (control) — фокусировка/потеря фокуса на элементе;
•input/change (control) — изменение значения ввода/окончание изменения значения;
•submit (control) — отправка формы <form></form>;
•DOMContentLoaded (document) — HTML загружен и обработан, DOM полностью построен.

# ================================================================

# 17 -- Стадии (фазы) события

У каждого события есть три стадии (фазы):
1.Стадия погружения (перехвата);
2.Стадия цели;
3.Стадия всплытия.
По умолчанию все обработчики событий вызываются на стадии всплытия. Т.е. в момент возникновения события на элементе, обработчики сначала срабатывают на нём, затем на его родителе, затем на родителе родителя и так далее. Данный процесс и называется всплытием. В примере справа по клику на элементе <span></span> обработчик вызовется сначала на нём, затем на <h1></h1> и только после этого на <section></section>.

# ================================================================

# 18 -- Стадия цели

На стадии цели мы добираемся до целевого элемента. Получить доступ к этому элементу можно через свойство event.target.
Тут стоит обратить внимание, что в некоторых случаях event.target может быть равен event.currentTarget, однако в конечном итоге эти свойства говорят нам о разном, так что использовать их нужно всегда по прямому назначению. Event.currentTarget всегда ссылается на элемент, на котором сработал обработчик. Event.target — это элемент, который является инициатором событие.

Во время клика по <span></span>:
1.На стадии цели элемента <span></span> оба свойства target и currentTarget объекта event будут ссылаться на элемент <span></span>.
2.На стадии цели элемента <h1></h1> свойство target будет ссылаться на элемент <span></span>, а currentTarget уже на <h1></h1>.
3.На стадии цели элемента <section></section>, аналогично ситуации с элементом <h1></h1>, свойство target будет ссылаться на <span></span>, а currentTarget на <section></section>.

# ================================================================

# 19 -- Стадия погружения

Стадия погружения в большинстве случаев остаётся для нас незаметной. Однако в некоторых ситуациях у разработчиков всё же может возникнуть необходимость обработать событие именно на ней. Для определения фазы, на которой выполняется обработчик, существует свойство event.eventPhase. Однако оно почти не используется т.к. в большинстве случаев мы и так знаем, на какой стадии вызывается обработчик. Для добавления обработки события на фазе погружения нужно использовать третий параметр метода addEventListener(_, _, options). Другие способы назначения обработчиков не позволяют нам изменять фазу для отлова события.
Указать стадию для обработки события можно “двумя" способами:
•Прокинуть третьим параметром объект со свойством capture равным true, если нужно отловить событие на стадии погружения и false — в ином случае;
•Прокинуть третьим параметром значение true или false (эффект аналогичен первому варианту).
** Стоит отметить, что таким образом можно отловить события лишь на фазах погружения и всплытия. Нет возможности как-то привязать обработчик к стадии цели. На этой стадии всегда вызываются все обработчики, существующие на элементе.

Примечание. Для удаления обработчика всегда нужна та же фаза, что использовалась при его назначении.

# ================================================================

# 20 -- Обработчики событий

Обработчик события — это функция, которая срабатывает в момент возникновения события. В JavaScript обработчики событий можно навешивать несколькими способами.
Первый способ — это назначение обработчика прямо в HTML. Делается это при помощи присваивания атрибутам, имена которых складываются из ‘on’ + ‘название события’, фрагментов JavaScript-кода. Например:

Однако тут сразу возникает проблема: “а что если нужно выполнить сразу несколько операций на нажатие кнопки?” Это можно сделать, разделив их код знаком ‘;’. Например:

Но это не сильно решает проблему. Т.к. места в HTML код занимает уже много, но делает при этом очень мало. Код, состоящий из 3 и более операций будет очень сильно нагромождать нашу разметку. В такой ситуации лучше всего подойдёт вызов функции. Например:

# ================================================================

# 21 -- Свойства DOM-элементов

Похожим способом можно навешивать обработчики с помощью встроенных свойств DOM-элементов. 
По умолчанию каждый элемент содержит все возможные свойства для обработки событий со значениями null. 
Это означает, что данные события на этом элементе не обрабатываются (конечно, если обработчики не навешаны с помощью addEventListener, но об этом позже). 
Для обработки события нужно просто соответствующему свойству присвоить функцию. Например:

** Для удаления обработчика нужно снова присвоить свойству значение null.


# ================================================================

# 22 -- addEventListener

Самым удобным способом назначить обработчик события является использование метода addEventListener. 
Данный способ позволяет назначить неограниченное число обработчиков на одно и то же событие элемента. Метод addEventListener принимает три аргумента:
•eventName – название события, на которое назначается обработчик (например, ‘click’ или ‘mouseout’);
•eventHandler – функция-обработчик;
?options – необязательный параметр, который может быть или объектом со свойствами { ?capture, ?once, ?passive }, или значением true/false, что будет аналогично записи { capture: true/false }.



# ================================================================

# 23 -- removeEventListener

Есть два способа удалить обработчик, назначенный с помощью addEventListener:
1.Воспользоваться методом removeEventListener, который удаляет обработчик по ссылке.
2.Во время назначения обработчика третьим параметром передать объект со значением once равным true. После первого срабатывания обработчик будет автоматически удалён.
Метод removeEventListener(eventName, eventHandler, ?capture) принимает три параметра, два из которых точно такие же, как у метода addEventListener. Третий параметр требует указания фазы, с которой снимается обработчик. То есть если обработчик был назначен на стадию погружения, то и удаляться он должен с этой же фазы. В ином случае ничего не удалится.
Здесь важно отметить, что removeEventListener ожидает ссылку на функцию-обработчик, которая была назначена ранее. Т.е. нам нужна та же ссылка, что была использована в addEventListener. Использовать новую функцию с идентичным телом не получится.


# ================================================================

# 24 -- Объект события (event)

Каждый раз, когда браузер посылает сигнал о возникновении события, вместе с ним он инициализирует и отправляет специальный объект события. Данный объект содержит информацию о том, что произошло. Например, какая клавиша была нажата на клавиатуре или какие координаты имел курсор мыши во время срабатывания события клика. Объект события в функцию-обработчик всегда поступает в качестве первого параметра.
Объекты события могут быть разными. Например, упомянутый ранее объект события нажатия клавиши клавиатуры отличается от объекта нажатия клавиши мыши. Тем не менее каждый из них содержит ряд общих свойств и методов. Некоторые из этих свойств:
•event.target – элемент, который является инициатором события (или целевой элемент);
•event.currentTarget – элемент, на котором непосредственно задан обработчик события(1);
•event.type – тип события в виде строки (например, ‘click’).
(1) Также ссылку на элемент, на котором назначен обработчик, можно получить через this. Значение this — и есть ссылка на данный элемент. Однако работает это не всегда, как, например, в случае использования стрелочных функций.


Ранее упоминалось о том, что объект события помимо встроенных свойств также имеет и некоторые методы. Рассмотрим самые популярные из них:
•event.preventDefault() — отмена действия по умолчанию (например, добавления символа в поле для ввода на ‘keydown’ или появления контекстного меню в браузере на ‘contextmenu’);
•event.stopPropagation() — прекращение дальнейшего распространения события. Т.е. после вызова этого метода, event завершит погружение (или всплытие) и ни один из оставшихся обработчиков на других событиях вызван не будет;
•event.stopImmediatePropagation() — тоже, что и event.stopPropagation(), но в дополнение предотвращение вызова других обработчиков на текущем элементе. Т.е. если на одном элементе висит сразу три обработчика на ‘click’, вызов event.stopImmediatePropagation() в одном из них предотвратит вызов оставшихся.

Кроме event.preventDefault() действие по умолчанию можно отменить с помощью возвращения значения false в теле функции-обработчика. 
Однако такой подход сработает только если обработчик назначен через атрибут или свойство (т.е. не с помощью метода addEventListener).
Для определения, было ли отменено действие по умолчанию, объект события имеет специальное свойство event.defaultPrevented. 
До тех пор, пока у объекта события не был вызван метод event.preventDefault(), данное свойство содержит значение false. 
Если же вызов произошёл, свойство сразу же начинает “отдавать” значение true. 
Это может быть удобно, если сразу в нескольких обработчиках вам нужно следить за тем, было ли отменено действие по умолчанию или нет.
Кроме этого у объекта опций метода addEventListener есть поле passive, которое указывает, 
будет вызываться метод event.preventDefault() на объектах событий или нет. 
Если passive равно true, значит не будет. 
Если даже после указания passive: true вызов метода произойдёт, то он будет проигнорирован и в добавок к этому будет сгенерировано консольное предупреждение. 
Эта возможность бывает полезной, когда нам нужно дать понять браузеру, что он может начать выполнять действие по умолчанию не дожидаясь завершения работы всех обработчиков.

# ================================================================

# 25 -- Делегирование событий

Иногда мы сталкиваемся с ситуациями, когда в некоторой области существует множество однотипных элементов, 
каждый из которых должен обрабатывать одно и то же событие по единому алгоритму. Моим любимым примером такой ситуации служит игра сапёр. 
Для каждой ячейки нам нужно назначить два обработчика: один на клик левой клавишей мыши и один на клик правой. 
Мы, конечно, можем навесить на каждую ячейку по два отдельных обработчика, но только подумайте, сколько таких обработчиков получится на поле размером 10x10. 
А 20x20? Многовато.
Такие ситуации встречаются не так уж редко и, естественно, для них есть отличное решение — делегирование событий. 
Его суть сводится к тому, что для обработки одного события на всех элементах сразу нам потребуется назначить всего один обработчик на контейнере. 
В обработчике на основе информации о целевом элементе (свойство event.target) мы производим или не производим дальнейшие операции. 
Зачастую в таких ситуациях ориентиром служит класс элемента. Например: event.target.classList.contains(‘cell’).

Вернёмся к нашему примеру с игрой сапёр. Для применения делегирования событий нам нужно назначить всего два обработчика: 
один на событие ‘click’ и второй на ‘contextmenu’. Прослушивать данные события будет поле, внутри которого располагаются все наши ячейки.

# ================================================================

# 26 --

# ================================================================

# 27 --

# ================================================================

# 28 --
