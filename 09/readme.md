# 3 -- Как работает JS?

Объектно-ориентированное программирование (далее ООП) — это парадигма программирования, которая строится на базе понятий класса и объекта.

Класс — это шаблон или схема, на основании которой будут создаваться новые объекты.

Объекты — это конкретные экземпляры класса. То есть сущности, созданные по заданному шаблону. Каждая такая сущность будет иметь чёткий набор характеристик (поля класса) и действий (методы класса). При этом каждый объект также будет иметь своё собственное внутреннее состояние, к которому в большинстве языков программирования можно получить доступ через this.

Кроме этого ООП имеет несколько базовых принципов:

- 1.Наследование.
- 2.Инкапсуляция.
- 3.Полиморфизм.

# ================================================================

# 4 -- Принципы ООП

Хоть JavaScript и считается мультипарадигменным языком программирования, чистого ООП в нём совсем немного. Тем не менее в JavaScript есть некоторые инструменты, которые позволяют нам неплохо имитировать ОПП и успешно применять его на практике.
- 1.В JavaScript “есть" наследование. Однако реализовано оно через прототипы (о них позже). Реализация наследования через прототипы хоть и работает очень хорошо, но всё же имеет некоторые особенности.
- 2.В JavaScript “очень слабая” инкапсуляция. Проявляется она по большей части в рамках использования каких-то сторонних библиотек или модулей.
- 3.В JavaScript “слабый” полиморфизм. Без строгой типизации с полиморфизмом “дружить” сложно, но можно. Например, функция, которая в качестве параметра должна принимать объект, может также корректно работать и с массивами, и с функциями.

# ================================================================

# 5/10 -- SOLID

SOLID(1) — это аббревиатура, скрывающая в себе набор из пяти базовых принципов разработки приложений с применением ООП. Знание и понимание этих принципов помогает разработчикам найти общий язык в решении споров по качеству построения архитектуры.
- 1.(S) Single responsibility principle — принцип единственной ответственности (обязанности).
  Каждый класс должен отвечать только за одну операцию.

- 2.(O) Open/closed principle — принцип открытости/закрытости.
  Классы должны быть открыты для расширения, но закрыты для модификации.

- 3.(L) Liskov substitution principle — принцип постановки Барбары Лисков.
  Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.

- 4.(I) Interface segregation principle — принцип разделения интерфейсов.
  Не следует ставить клиент в зависимость от методов, которые он не использует.

- 5.(D) Dependency inversion principle — принцип инверсии зависимостей.
  Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

https://habr.com/ru/company/productivity_inside/blog/505430/

# ================================================================

# 11 -- Прототипы

Каждый объект в JavaScript имеет скрытое свойство [[Prototype]]. Данное свойство может ссылаться на объект или быть равным null.
Прототипы, хоть зачастую и являются объектами, всё же имеют некоторые отличия. Например, если мы попытаемся обратиться к несуществующему полю какого-то объекта, JavaScript автоматически начнёт поиск этого поля в его прототипе (а затем в прототипе прототипа и т.д.).
Несмотря на то, что свойство [[Prototype]] является скрытым, на сегодняшний день есть множество способов для чтения и изменения его значения. Одним из таких является геттер/сеттер __proto__.

# ================================================================

# 12 -- Перебор свойств у объекта

Цикл for..in проходит как по ключам объекта, так и по ключам прототипов. 
Если мы хотим работать только с внутренними свойствами (или методами) объектов, 
то можно воспользоваться встроенным методом .hasOwnProperty(propertyKey). 
Однако тут может возникнуть вопрос: откуда берётся этот метод? Ответ довольно прост:
из прототипа объекта. 
Но тогда возникает ещё один вопрос: почему тогда for..in не вывел этот ключ вместе с остальными? 
Тут ответ несколько сложнее: данное свойство не перечисляемо 
(т.е. у него [свойства] в дескрипторе задана конфигурация { enumerable: false }).

# ================================================================

# 13 --Современные способы работы с прототипами

•Задание прототипа:
1.Object.create(proto, ?properties) — создание нового объекта со значением свойства [[Prototype]] равным proto.
2.Object.setPrototypeOf(obj, proto) — устанавливает значение proto для свойства [[Prototype]] у объекта obj (по сути работает также, как и сеттер __proto__).

•Получение прототипа:
1.Object.getPrototypeOf(obj) – возвращает значение свойства [[Prototype]] объекта obj (по сути работает также, как и геттер __proto__).

# ================================================================

# 14 -- ООП в JS

В JavaScript на сегодняшний день существует три два способа реализации ООП. А именно:
1.ООП в прототипном стиле;
2.ООП на классах ES6;
3.ООП в функциональном стиле.

Реализация ООП в функциональном стиле уже окончательно устарела и почти нигде не используется. Поэтому подробно рассматривать её мы не будем.
Реализация ООП в прототипном стиле в своём первоначальном виде уже также мало где используется. Однако для изучения классов ES6 нужно обязательно знать и понимать как она функционирует.


Хоть мы и опустили шаг с разбором функционального подхода к реализации ООП, не упомянуть его совсем не получится. Так почему же именно прототипное наследование стало предпочтительным вариантом, на основе которого в будущем даже были реализованы классы ES6?
Главная причина — производительность. В функциональном подходе каждый новый экземпляр класса по-новой создавал все методы этого класса. Т.е. если мы, к примеру, создадим 1000 экземпляров, то на выходе будем иметь 1000 объектов, в каждом из которых будут храниться свои независимые функции (методы), а это очень большой перерасход памяти. В прототипном подходе мы создаём всего одну функцию для всех экземпляров класса и обращаемся к ней через прототип.
Кроме этого немаловажную роль играет сохранение функций родительского класса. В прототипном стиле за счёт как раз таки свойств прототипа мы можем сохранять все реализации одного и того же метода на разных уровнях. При необходимости перезаписать метод мы не перезаписываем его напрямую, а лишь складываем новую его реализацию на уровень выше, чтобы при поиске метода по такому ключу именно она была найдена в первую очередь.

# ================================================================

# 15 --Классы в прототипном стиле

# ================================================================

# 16 -- Наследование в прототипном стиле


# ================================================================

# 17 -- Почему именно подход на прототипах?

Хоть мы и опустили шаг с разбором функционального подхода к реализации ООП, не упомянуть его совсем не получится. Так почему же именно прототипное наследование стало предпочтительным вариантом, на основе которого в будущем даже были реализованы классы ES6?

Главная причина — производительность. В функциональном подходе каждый новый экземпляр класса по-новой создавал все методы этого класса. Т.е. если мы, к примеру, создадим 1000 экземпляров, то на выходе будем иметь 1000 объектов, в каждом из которых будут храниться свои независимые функции (методы), а это очень большой перерасход памяти. В прототипном подходе мы создаём всего одну функцию для всех экземпляров класса и обращаемся к ней через прототип.

Кроме этого немаловажную роль играет сохранение функций родительского класса. В прототипном стиле за счёт как раз таки свойств прототипа мы можем сохранять все реализации одного и того же метода на разных уровнях. При необходимости перезаписать метод мы не перезаписываем его напрямую, а лишь складываем новую его реализацию на уровень выше, чтобы при поиске метода по такому ключу именно она была найдена в первую очередь.

# ================================================================

# 18 -- Классы ES6

В ES6 в JavaScript появились классы. Это был довольно мощный шаг в сторону ООП и с тех пор данный синтаксис стал основным для работы с ними [классами].
Классы в JavaScript — это просто одна из разновидностей функций. Если мы попробуем вызвать typeof для класса, то получим ‘function’.
Довольно часто можно услышать, что классы ES6 – это просто "синтаксический сахар” над прототипной реализацией ООП в JavaScript. Отчасти это так, но не до конца.
1.Весь код внутри классов всегда работает в строгом режиме!
2.Все методы класса по умолчанию являются неперечисляемыми. Т.е. для всех методов в prototype автоматически выставляется конфигурация { enumerable: false }.
3.Мы не можем вызвать класс без ключевого слова new, т.е. просто как обычную функцию.

# ================================================================

# 19 -- Class Expression

Так как классы – это те же функции, они также могут быть сохранены в переменных.
Кроме этого классы могут являться возвращаемым значением функций, что бывает нужно очень редко, но тем не менее может быть использовано.

# ================================================================

# 20 -- get/set

В классах можно создавать геттеры и сеттеры свойств. Для этого просто нужно перед названием свойства поставить ключевое слово get для реализации логики по записи значения или set для реализации логики по чтению значения.
В конечном итоге мы как бы “создаём” полноценное свойство класса, которое может быть изменено или прочитано самыми обычными способами.

# ================================================================

# 21 -- наследование

Наследование классов осуществляется с помощью ключевого слова extends. “Под капотом” наследование работает также, как и в прототипном стиле реализации классов.
Аналогичным образом можно расширять классы обычными функциями-конструкторами.
Классы не могут расширять обычные (non-constructible) объекты. Если вам необходимо создать наследование от обычного объекта, в качестве замены можно использовать Object.setPrototypeOf().

# ================================================================

# 22 -- super

Вместе с ES6 классами появляется новое ключевое слово super.
При вызове super как функции мы вызываем конструктор базового класса. При этом важно знать то, что в конструкторе производного класса невозможно обратиться к this до вызова super (иначе будет ошибка!).
Также super содержит в себе ссылки на методы базового класса. Т.е. this.sayHi() — это вызов метода sayHi непосредственно у самого класса, а super.sayHi() — это вызов метода sayHi у базового класса.


# ================================================================

# 23 -- поля(свойства) класса

В классах появилась возможность добавлять поля (свойства). Поле – это переменная внутри класса. Ранее они всегда назначались напрямую через this. В классах же они могут быть описаны прямо в теле и даже со значениями по умолчанию.
С помощью ключевого слова static мы можем определить статические поля и методы класса. Обратиться к ним можно напрямую по имени класса без создания экземпляров.
В ES10 классы расширили возможностью создания приватных полей и методов. Данная возможность достигается с помощью знака решётки ‘#’ в начале названия соответствующего поля или метода.
